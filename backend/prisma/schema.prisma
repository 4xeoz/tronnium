// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

//
// Enums
// 

enum AssetDomain {
  IT
  OT
  UNKNOWN
}

enum MatchMethod {
  CPE_NAME        // NVD CVE query used ?cpeName=
  KEYWORD_SEARCH  // NVD CVE query used ?keywordSearch=
  NONE            // not enough info / failed
}

//
// Core Auth / User
// You’re using Google OAuth + JWT in your app.
// This schema stores the user identity and basic profile info.
//

model UserAccount {
  id             String   @id @default(uuid()) @db.Uuid

  // Primary identity (unique)
  email          String   @unique

  displayName String?
  avatarUrl   String?
  role        String   @default("user")

  // Google identity: "sub" claim is stable per Google account
  googleSubjectId  String?  @unique

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // environments   Environment[]

  @@index([createdAt])
  environments Environment[]
}



//
// Multi-tenant workspace-style structure
// User -> Environment -> Assets
// 


model Environment {
  id              String          @id @default(uuid()) @db.Uuid

  ownerId         String          @db.Uuid
  owner           UserAccount     @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  name            String          // e.g. "HQ IT", "Plant A OT", "Cloud Prod"
  description     String?

  // Useful for filtering (prod/dev/lab, plant-a, region-uk)
  labels          String[]        @default([])

  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  assets          Asset[]

  @@index([ownerId])
}


//
// Assets
// Store BOTH:
// 1) What user typed (raw fields)
// 2) Your normalized structured identity (best-effort)
//
// Keep it “lightweight columns” for filtering + JSON for flexible details.
//



model Asset {
  id                String      @id @default(uuid()) @db.Uuid

  environmentId     String      @db.Uuid
  environment       Environment @relation(fields: [environmentId], references: [id], onDelete: Cascade)

  // ---- User-entered fields ----
  rawAssetName      String?     // optional friendly name, e.g. "Main Firewall"
  rawDescription    String      // the messy input, e.g. "forti fg 60e main firewall"

  // Optional: user can attach their own tags
  tags              String[]    @default([])

  // ---- Normalized identity (from Gemini/LLM extraction) ----
  domain            AssetDomain @default(UNKNOWN)

  vendorName        String?     // e.g. "fortinet", "siemens", "microsoft"
  productName       String?     // e.g. "fortigate", "windows_server", "ignition"
  productFamily     String?     // OT-friendly: "simatic_s7_1500", "control_logix"
  modelIdentifier   String?     // e.g. "60e", "cpu1511-1pn", "pa-220"
  operatingSystem   String?     // e.g. "windows", "ubuntu", "rhel"

  softwareVersion   String?     // IT software/service version, e.g. "2.4.58"
  firmwareVersion   String?     // OT firmware version, e.g. "2.8"
  assetRole         String?     // keep as string for now: "firewall", "plc", "hmi", "server", etc.

  // ---- NVD matching summary fields ----
  bestMatchedCpe    String?     // top CPE you picked (if any)
  matchMethod       MatchMethod @default(NONE)

  // Pipeline confidence (0..1) from your scoring
  normalizationConf Float?      @db.Real

  // When you last ran analysis against NVD
  lastAnalyzedAgainstNvd    DateTime?

  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  analyses          AssetAnalysis[]

  @@index([environmentId])
  @@index([domain])
  @@index([vendorName, productName])
  @@index([bestMatchedCpe])
}


//
// AssetAnalysis
// Each time you run your pipeline (normalize → discover CPE → query NVD CVEs),
// write one row. This gives you history and evaluation data.
//

model AssetAnalysis {
  id                 String      @id @default(uuid()) @db.Uuid

  assetId            String      @db.Uuid
  asset              Asset       @relation(fields: [assetId], references: [id], onDelete: Cascade)

  // The original prompt input you analyzed (so you can reproduce runs)
  inputText          String

  // ---- Output snapshots (store as JSON to stay flexible) ----
  extractedIdentity  Json        // Gemini extraction (vendor/product/model/version/role/evidence)
  cpeCandidates      Json?       // list of {cpeName, confidence, title, evidence}
  nvdQuery           Json?       // store query params used (cpeName or keywordSearch, pagination, etc.)

  // Store CVEs (either full CVE objects or just ids + key fields)
  nvdCveResults      Json?

  // Summary fields for easy filtering/metrics
  matchMethod        MatchMethod @default(NONE)
  topCpeConfidence   Float?      @db.Real
  cveCount           Int         @default(0)

  createdAt          DateTime    @default(now())

  @@index([assetId])
  @@index([createdAt])
  @@index([matchMethod])
}


